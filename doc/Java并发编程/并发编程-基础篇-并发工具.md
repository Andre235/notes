## 共享模型之工具

### 线程池

线程池基本组件

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.2qyjimlyq0s0.png" alt="image" style="zoom:50%;" />

#### 自定义线程池

##### 阻塞队列

```java
@Slf4j(topic = "BlockingQueue")
class BlockingQueue<T> {

    /**
     * 任务队列
     */
    private Deque<T> queue = new ArrayDeque<>();

    /**
     * 任务队列容量
     */
    private int capacity;

    /**
     * 保证任务队列的线程安全性
     */
    private ReentrantLock lock = new ReentrantLock();

    /**
     * 生产者条件变量(当任务队列满时，生产者线程处于等待状态)
     */
    private Condition productCondition = lock.newCondition();

    /**
     * 消费者条件变量(当任务队列为空时，消费者线程处于等待状态)
     */
    private Condition consumerCondition = lock.newCondition();

    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }

    /**
     * 带超时的阻塞获取，线程超过等待时间则放弃等待
     * @return 获取任务
     */
    public T poll (long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            // 将timeout超时时间统一转换成 纳秒
            long nanos = timeUnit.toNanos(timeout);
            // 如果任务队列为空，则使生产者线程处于等待状态
            while (queue.isEmpty()) {
                try {
                    if (nanos <= 0) {
                        return null;
                    }
                    // 返回的是剩余等待时间，防止虚假唤醒
                    nanos = consumerCondition.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            productCondition.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞获取
     * @return 获取任务
     */
    public T take () {
        lock.lock();
        try {
            // 如果任务队列为空，则使生产者线程处于等待状态
            while (queue.isEmpty()) {
                try {
                    consumerCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            productCondition.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    /**
     * 阻塞添加
     * @param task 向阻塞队列中添加任务
     */
    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                try {
                    productCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(task);
            consumerCondition.signal();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 带超时时间的阻塞添加
     * @param task 任务
     * @param timeout 超时时间
     * @param timeUnit 超时时间单位
     * @return 添加是否成功
     */
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    log.info("等待加入阻塞队列...");
                    if (nanos <= 0) {
                        return false;
                    }
                    nanos = productCondition.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(task);
            consumerCondition.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    /**
     * @return 获取阻塞队列容量大小
     */
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否已满
            if (queue.size() == capacity) {
                // 拒绝策略权利下放至rejectPolicy
                rejectPolicy.reject(this, task);
            } else {
                log.info("任务加入阻塞队列");
                queue.addLast(task);
                consumerCondition.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

##### 拒绝策略

```java
@FunctionalInterface
interface RejectPolicy<T> {

    void reject(BlockingQueue<T> blockingQueue, T task);
}
```

##### 线程池

```java
@Slf4j(topic = "ThreadPool")
class ThreadPool {

    /**
     * 任务队列
     */
    private BlockingQueue<Runnable> blockingQueue;
    /**
     * 线程集合
     */
    private Set<Worker> workers = new HashSet<>();

    /**
     * 核心线程数量
     */
    private int coreSize;

    /**
     * 获取任务的超时时间
     */
    private long timeout;

    /**
     * 超时时间单位
     */
    private TimeUnit timeUnit;

    /**
     * 拒绝策略
     */
    private RejectPolicy<Runnable> rejectPolicy;

    /**

     */
    /**
     * 构造方法
     * @param coreSize 核心线程池数量
     * @param timeout 线程从阻塞队列获取任务的超时时间
     * @param timeUnit 超时时间单位
     * @param queueCapacity 阻塞队列容量
     * @param rejectPolicy 拒绝策略
     */
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.blockingQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    public void execute (Runnable task) {
        // 保证workers 集合线程安全
        synchronized (workers) {
            if (workers.size() < coreSize) { // 如果任务数量没有超过 coreSize，则直接交给worker对象执行
                Worker worker = new Worker(task);
                log.info("创建worker工作线程：{}, 任务对象：{}", worker, task);
                worker.start();
                workers.add(worker);
            } else { // 如果任务数量超过了 coreSize，则将当前任务加入阻塞队列
                log.info("将当前任务添加至阻塞队列：{}", task);
                // blockingQueue.put(task);

                // 阻塞队列满时，如何处理(策略模式实现)？
                // 1.死等
                // 2.带超时的等待
                // 3.让调用者放弃执行任务
                // 4.让调用者抛出异常
                // 5.让调用者自己执行任务
                blockingQueue.tryPut(rejectPolicy, task);
            }
        }
    }

    // @Slf4j(topic = "Worker")
    class Worker extends Thread{
        private Runnable task;

        public Worker (Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
            // 执行任务
            // 1.当worker对象被创建时，task对象不为空，表示有任务提交过来，可以直接执行
            // 2.当task执行完毕，这个时候执行阻塞队列中的任务
            // while (task != null || (task = blockingQueue.take()) != null) {
            while (task != null || (task = blockingQueue.poll(2, TimeUnit.SECONDS)) != null) {
                try {
                    log.info("正在执行：{}任务", task);
                    task.run();

                } catch (Exception exception) {
                    exception.printStackTrace();
                } finally {
                    task = null;
                }
            }
            // 任务执行完毕，从works 集合中移除掉当前工作线程
            synchronized (workers) {
                log.info("当前线程：{} 执行完毕，从工作线程集合中被移除", this);
                workers.remove(this);
            }
        }
    }
}
```

##### 测试类4

```java
@Slf4j(topic = "ThreadPool")
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(
                1,
                1000,
                TimeUnit.MILLISECONDS,
                1,
                (queue, task) -> {
                    // 1.死等
                    // queue.put(task);
                    // 2.带超时的等待
                    // queue.offer(task, 1500, TimeUnit.MILLISECONDS);
                    // 3.让调用者放弃执行任务
                    // log.info("放弃任务执行");
                    // 4.让调用者抛出异常
                    // throw new RuntimeException("任务执行失败 " + task);
                    // 5.让调用者自己执行任务
                    task.run();
                }
        );
        for (int i = 0; i < 3; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.info("{}", j);
            });
        }
    }
}
```

#### ThreadPoolExecute

##### JDK线程池类图

![image](https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.7aknpwv4d9o0.png)

##### 1)线程池状态

ThreadPoolExecute使用int类型的高3位表示线程池状态，低29位表示线程数量

注意：第一位是符号位，1表示负数；0表示正数

| 状态名             | 高3位 | 接收新任务 | 处理阻塞队列任务 | 说明                                                  |
| ------------------ | ----- | ---------- | ---------------- | ----------------------------------------------------- |
| RUNNING            | 111   | Y          | Y                |                                                       |
| SHUTDOWN(温和结束) | 000   | N          | N                | 不会接收新任务，但是会处理阻塞队列的剩余任务          |
| STOP               | 001   | N          | N                | 会中断正在执行的任务，并且抛弃阻塞队列的任务          |
| TIDYING            | 010   | -          | -                | 任务全部执行完毕，活动线程数量为0时，即将进入终结状态 |
| TERMINATED         | 011   | -          | -                | 终结状态                                              |

从数字上比较，TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING

**Q：线程池设计时为什么用一个整数来存储两个信息（线程池状态信息、线程数量信息）呢？**

A：这些信息存储在一个原子变量ctl中，目的是将线程池状态与线程个数合二为一，这样就可以用一次CAS原子操作进行赋值

```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));

// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

##### 2)线程池构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler){}
```

- corePoolSize 核心线程池数量（最多保留的线程数）
- maximumPoolSize 最大线程池数量
- keepAliveTime 生存时间（针对救急线程）
- unit 时间单位 - 针对救急线程 
- workQueue 阻塞队列 
- threadFactory 线程工厂 - 可以为线程创建时起个好名字 
- handler 拒绝策略

##### 线程池的任务提交流程

假设corePoolSize = 3， maximumPoolSize = 5， blockingQueueSize = 10，keepAliveTime = 3秒

一开始有三个任务提交进来，这个三个任务由核心线程执行；接着有10个任务提交进来，这是核心线程池数量已经满了，此时的10个任务将放入阻塞队列中被等待执行；这个时候又有2个任务提交进来，这时阻塞队列也满了，最大线程池数量为5，核心线程池数量为3，表示线程池还可以**临时创建**2个**救急线程**来处理这两个任务；这时如果还有任务提交，则触发拒绝策略。救急线程处理完任务之后，过了`keepAliveTime` 设置的时间也就是3秒后，救急线程自动销毁

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/image.2zsa9zzufi40.png" alt="image" style="zoom:50%;" />

#### Fork/Join

### J.U.C

#### AQS原理

#### ReentrantLock 原理

#### 读写锁

#### ReentrantReadWriteLock

#### 应用之缓存

#### 读写锁原理

####  StampedLock

#### Semaphore

##### 基本使用

##### Semaphore应用

##### Semaphore原理

#### CountdownLatch

##### 应用之同步等待多线程执行完毕

##### 应用之同步等待多个远程调用结束

#### CyclicBarrier

#### 线程安全集合类概述

#### ConcurrentHashMap

##### 单词计数

##### ConcurrentHashMap原理

#### BlockingQueue

##### BlockingQueue原理

#### ConcurrentLinkedQueue

#### CopyOnWriteArrayList

##### get弱一致性

##### 迭代器若一致性

