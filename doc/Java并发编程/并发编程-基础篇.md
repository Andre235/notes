---
typora-root-url: imgs
---

### 进程与线程

#### 进程和线程

##### 进程

- 进程由`指令`和`数据`组成。一个进程的运行需要将指令加载进CPU、数据加载进内存。在进程运行过程中还需要用到磁盘、网络等设备。综上，进程是用来加载指令、管理内存、管理IO的程序集
- 当一个程序运行时，从磁盘加载这个程序的代码至内存，这时也就开启了一个进程
- 进程也可以理解为一个程序的实例。大部分程序可以运行多个进程实例（记事本、浏览器），当然有个程序只能运行一个进程实例（微信、网易云音乐）

##### 线程

- 一个进程之内可以运行多个线程
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行
- 线程是CPU调度的最小单位

##### 二者对比

- 进程之间相互独立。线程存在于进程的内部，是进程的一个子集
- 进程拥有共享资源，如内存空间，供其内部的线程共享使用
- 进程之间的通信比较复杂
    - 同一台计算机内的进程通信称为IPC（Inter Process Communication）通信
    - 不同计算机之间的进程通信，需要经过网络通信，并且遵守一定的协议（HTTP协议）
- 线程之间通信比较简单，因为它们共享进程的内存空间（eg：多个线程可以访问同一个共享变量）
- 线程更加轻量级，线程的上下切换的开销一般要比进程之间的上下文切换开销低

#### 并发与并行

##### 并发

单核CPU下，多个线程实际还是`串行执行`的。操作系统中有一个组件叫做`任务调度器`，可以将CPU的时间片（Windows下时间片最小为15毫秒）划分给不同的线程使用，由于CPU在不同之间的时间片切换是非常快的，对用户来说感知不到这个切换的过程，因此用户感觉线程是并行运行的。

总结：*微观串行，宏观并行*

<img src="C:\Users\lucas.zhao\AppData\Roaming\Typora\typora-user-images\image-20210615180503082.png" alt="image-20210615180503082" style="zoom:50%;" />

一般将线程轮流使用CPU的做法称之为并发（Concurrent）

##### 并行

多核CPU下，每个核心都可以调度运行线程，这个时候线程可以是并行的（Parallel）

##### 应用之异步调用

从方法的调用角度来讲，如果**需要等待**方法的结果才可以继续运行，这就是**同步**；如果**不需要等待**方法的结果就可以继续运行，这种就是**异步**

设计：多线程的使用可以让方法的执行变成异步的

##### 应用之提高效率

### 3. Java线程

#### 本章内容

1. 创建和运行线程
2. 查看线程
3. 线程API
4. 线程状态

#### 3.1 创建和运行线程

##### Thread

```java
@Slf4j(topic = "c.test")
public class TheadTest {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            @Override
            public void run() {
                log.info("running...");
            }
        };
        thread.start();
        log.info("test");
    }
}
```

##### Runnable

```java
@Slf4j(topic = "RunnableTest")
public class RunnableTest {
    public static void main(String[] args) {
        Runnable runnable = new Runnable(){
            @Override
            public void run() {
                log.info("running...");
            }
        };
        Thread thread = new Thread(runnable, "t1");
        thread.start();

        lambda();
    }

    private static void lambda() {
        Thread thead1 = new Thread(() -> log.info("lambda test..."), "thead1");
        thead1.start();
    }
}
```

#### 3.2 查看和杀死进程

##### Windows

1. tasklist 查看进程

2. taskkill杀死进程

   ```shell
   tasklist | findstr java
   taskkill /F /PID 进程id
   ```

3. jps 查看java进程

##### Linux

1. ps -ef 查看所有进程信息
2. ps -fT -p <PID> 查看某个进程的所有线程信息
3. kill 杀死进程
4. top 实时查看进程信息
5. top -H -p <PID> 查看某个进程的所有线程信息

##### Java

1. jps 查看所有java进程

2. jstack <PID> 查看java进程的线程状态

3. jconsole 查看某个java进程的所有线程运行状态（图形化界面）

4. jconsole 远程监控配置

   ```shell
   java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
   Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
   Dcom.sun.management.jmxremote.authenticate=是否认证 java类
   ```

#### 3.3 线程运行原理

##### 栈和栈帧

我们都知道JVM由栈内存、堆内存、方法区构成。每个线程启动的时候JVM就会划分一部分栈内存给线程使用。

1. 其中每个栈由多个栈帧(Frame)构成，对应着每个方法调用时所占用的内存
2. 每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法

##### 线程上下文切换

可能以下原因的出现导致CPU不在执行当前线程，转而执行其他线程

1. 线程的CPU时间片用完
2. 垃圾回收
3. 有更高优先级的线程抢先执行
4. 线程自己调用了sleep、wait、yield、join、park、synchronized、park等方法导致释放了CPU资源

当发生上下文切换时，需要由操作系统保存当前线程的执行状态，并且恢复另外一个线程的状态。在java中对应的就是`程序计数器`去记录该状态（线程私有）

#### 3.4 线程的常见方法

| 方法名            | static | 功能说明                                                 | 注意                                                         |
| ----------------- | ------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| start()           |        | 启动一个新线程，在新线程中运行run 方法中的代码           |                                                              |
| run()             |        | 新线程启动后会调用该方法中的代码                         |                                                              |
| join()            |        | 等待线程运行结束                                         |                                                              |
| join(long)        |        | 指定一段时间后（时间单位：秒）等待线程运行结束           |                                                              |
| getId()           |        | 获取线程id                                               |                                                              |
| getName()         |        | 获取线程名称                                             |                                                              |
| setName()         |        | 设置线程名称                                             |                                                              |
| getPriority()     |        | 获取线程优先级                                           |                                                              |
| setPriority(int ) |        | 设置线程优先级                                           |                                                              |
| getState()        |        | 获取线程运行状态                                         | Java线程中有六个状态（用enum表示）分别是：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED |
| isInterrupted()   |        | 判断线程是否被打断                                       | 不会清除`打断标记`                                           |
| isAlive()         |        | 线程是否存活                                             |                                                              |
| interrupt()       |        | 打断线程                                                 | 如果被打断线程处于sleep、wait、join状态这时会导致被打断线程抛出InterruptException，并且**清除打断标记**。<br />如果打断的是正在运行的线程，则会**设置打断标记**<br />处于park状态的线程被打断时也会**设置打断标记** |
| interrupted()     | static | 判断当前线程是否被打断                                   | **会清除打断标记**                                           |
| currentThread()   | static | 获取当前正在执行的线程                                   |                                                              |
| sleep(n)          | static | 使当前线程休眠n毫秒，休眠是让出cpu的时间片给其他线程使用 |                                                              |
| yield()           | static | 提示线程调度器让出当前线程对CPU的使用                    | 主要是为了测试和调度使用                                     |

#### 3.5 start() & run()

**区别：**直接调用run方法本质上主线程执行run方法里面的代码，并没有起到异步执行的作用；调用start方法的原理是：新开启一个线程，让新创建的线程去执行run方法的代码

```java
@Slf4j(topic = "StartRunTest")
public class StartRunTest {
    public static void main(String[] args) {
        Thread thread = new Thread("thread1") {
            @Override
            public void run() {
                log.info("thread1 running...");
            }
        };
        thread.run();
        log.info("main thread running...");
    }
}

12:37:33.792 [main] INFO StartRunTest - thread1 running...
12:37:33.794 [main] INFO StartRunTest - main thread running...
```

**线程启动前后的状态变化**

```java
 @Slf4j(topic = "ThreadStatusTest")
public class ThreadStatusTest {
    public static void main(String[] args) {
        Thread thread = new Thread("thread1") {
            @Override
            public void run() {
                log.info("thread1 running...");
            }
        };
        log.info("线程启动之前状态：{}", thread.getState());
        thread.start();
        log.info("线程启动之后状态：{}", thread.getState());
    }
}

12:47:28.068 [main] INFO ThreadStatusTest - 线程启动之前状态：NEW
12:47:28.074 [main] INFO ThreadStatusTest - 线程启动之后状态：RUNNABLE
12:47:28.075 [thread1] INFO ThreadStatusTest - thread1 running...
```

*一个线程如果处于`RUNNABLE`状态，则不能再次调用start方法，否则会抛异常*

#### 3.6 sleep() & yield()

##### sleep方法

1. 调用sleep方法会让线程从running状态切换为 timed waiting状态

2. 其他实现可以使用interrupt方法打断正在睡眠的线程，这是sleep方法会抛出 `InterruptException`

   ```java
   @Slf4j(topic = "Test7Interrupt")
   public class Test7Interrupt {
   
       public static void main(String[] args) throws InterruptedException {
           Thread thread = new Thread("thread1") {
               @Override
               public void run() {
                   log.info("thread1线程进入睡眠状态");
                   try {
                       Thread.sleep(2000);
                   } catch (InterruptedException e) {
                       log.info("thread1线程被唤醒");
                       e.printStackTrace();
                   }
               }
           };
           thread.start();
   
           Thread.sleep(1000);
           log.info("main线程开始打断 thread1线程");
           thread.interrupt();
       }
   }
   
   Connected to the target VM, address: '127.0.0.1:4839', transport: 'socket'
   15:22:23.271 [thread1] INFO Test7Interrupt - thread1线程进入睡眠状态
   15:22:24.270 [main] INFO Test7Interrupt - main线程开始打断 thread1线程
   15:22:24.270 [thread1] INFO Test7Interrupt - thread1线程被唤醒
   java.lang.InterruptedException: sleep interrupted
   Disconnected from the target VM, address: '127.0.0.1:4839', transport: 'socket'
   	at java.lang.Thread.sleep(Native Method)
   	at com.kuhan.ops.monitor.system.Test7Interrupt$1.run(Test7Interrupt.java:20)
   ```



3. 睡眠结束后的线程未必可以立即执行（只有抢占到时间片资源的线程才可以执行）

4. 建议使用TimeUnit的Sleep方法来代替Thread的Sleep方法，来提升可读性

##### yield方法

```java
Runnable task2 = () -> {
    int count = 0;
    while (true) {
        // 当前线程拿到时间片资源以后将其让出去，让给其他线程执行
        Thread.yield();
        System.out.println("        ------>task2: " + count ++);
    }
};
```

1. 调用yield方法会使当前线程从`RUNNING`执行状态切换为`RUNNABLE`就绪状态，然后调度执行其他线程
2. 具体的实现依赖操作系统的任务调度器

##### 区别

调用sleep方法之后线程处于`TIMED_WATIING`阻塞状态、调用yield方法之后线程处于`RUNNABLE`就绪状态，调度器会把时间片分给就绪状态的线程而不会分给阻塞状态的线程

##### 线程优先级

1. 线程优先级会提示调度器优先调度该线程，但是它仅仅是提示作用，因为线程调度器可以**忽略**它
2. 如果CPU比价忙，那么优先级高的线程有更多的机会获得时间片；但是如果CPU闲时，线程优先级几乎不起作用

```java
@Slf4j(topic = "Test8Yield")
public class Test8Yield {

    public static void main(String[] args){
        Runnable task1 = () -> {
          int count = 0;
          while (true) {
              System.out.println("------>task1: " + count ++);
          }
        };
        Runnable task2 = () -> {
            int count = 0;
            while (true) {
                // 当前线程拿到时间片资源以后将其让出去，让给其他线程执行
                // Thread.yield();
                System.out.println("        ------>task2: " + count ++);
            }
        };

        Thread thread1 = new Thread(task1, "task1");
        Thread thread2 = new Thread(task2, "task2");
        thread1.setPriority(Thread.MIN_PRIORITY);
        thread2.setPriority(Thread.MAX_PRIORITY);

        thread1.start();
        thread2.start();
    }
}
```

#### 3.7 join() 方法详解

> 等待线程运行结束

##### 为什么需要join

```java
@Slf4j(topic = "test10")
public class Test10 {

    private static int NUMBER = 0;

    public static void main(String[] args) {
        log.info("main start...");
        increase();
        log.info("main end...");
    }


    private static void increase() {
        new Thread(() -> {
            log.info("thread1 start...");
            try {
                TimeUnit.SECONDS.sleep(1);
                NUMBER ++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("thread1 end...");
        }, "thread1").start();
        log.info("number: {}", NUMBER);
    }
}
```

以上代码中main线程先于thread1线程执行完成之后就获取NUMBER的结果，所以NUMBER还是0

**使用join方法可以解决该问题：**

```java
@Slf4j(topic = "test10")
public class Test10 {

    private static int NUMBER = 0;

    public static void main(String[] args) throws InterruptedException {
        log.info("main start...");
        increase();
        log.info("main end...");
    }


    private static void increase() throws InterruptedException {
        Thread thread = new Thread(() -> {
            log.info("thread1 start...");
            try {
                TimeUnit.SECONDS.sleep(1);
                NUMBER++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("thread1 end...");
        }, "thread1");
        thread.start();
        thread.join();
        log.info("number: {}", NUMBER);
    }
}


16:38:55.374 [main] INFO test10 - main start...
16:38:55.419 [thread1] INFO test10 - thread1 start...
16:38:56.419 [thread1] INFO test10 - thread1 end...
16:38:56.419 [main] INFO test10 - number: 1
16:38:56.421 [main] INFO test10 - main end...
```

##### 应用之同步

##### 等待多个结果

##### 有时效的join

#### 3.8 interrupt方法详解

##### 打断处于阻塞状态的线程

打断处于sleep、wait、join状态（阻塞状态）的线程，会清除打断标记，并且会抛出`InterruptedException`异常

```java
@Slf4j(topic = "Test11Interrupt")
public class Test11Interrupt {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            log.info("sleep...");
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "thread1");

        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("interrupt...");
        thread.interrupt();
        log.info("thread interrupt state: {}", thread.isInterrupted());
    }
}

11:04:46.320 [thread1] INFO Test11Interrupt - sleep...
11:04:47.318 [main] INFO Test11Interrupt - interrupt...
11:04:47.318 [main] INFO Test11Interrupt - thread interrupt state: false
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at java.lang.Thread.sleep(Thread.java:340)
	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
	at com.kuhan.ops.monitor.system.Test11Interrupt.lambda$main$0(Test11Interrupt.java:18)
	at java.lang.Thread.run(Thread.java:748)
Disconnected from the target VM, address: '127.0.0.1:10471', transport: 'socket'
```

##### 打断处于正常运行状态的线程。

主线程只是将子线程的打断标记置为真，但是并没有真正的终止子线程的任务，子线程可以根据自己的打断状态来自行终止线程任务

```java
@Slf4j(topic = "Test12Interrupt")
public class Test12Interrupt {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                boolean isInterrupted = Thread.currentThread().isInterrupted();
                if(isInterrupted) {
                    log.info("thread1线程被主线程打断，终止执行任务...");
                    break;
                }
            }
        }, "thread1");
        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("interrupt...");
        thread.interrupt();
    }
}

11:23:45.895 [main] INFO Test12Interrupt - interrupt...
11:23:45.898 [thread1] INFO Test12Interrupt - thread1线程被主线程打断，终止执行任务...
```

##### interrupt使用场景

可以**优雅地停止**线程任务（让子线程自己判断是否需要停止线程任务）

#### 3.9 不推荐使用的方法

还有一些不推荐使用的方法，这些方法已经过时并且容易破坏同步代码块，造成线程死锁

| 方法名  | static | 功能说明             |
| ------- | ------ | -------------------- |
| stop    |        | 停止线程运行         |
| suspend |        | 挂起（暂停线程运行） |
| resume  |        | 恢复线程运行         |

#### 3.10 主线程与守护线程

##### 主线程

默认情况下Java线程即主线程需要等待所有其他子线程运行结束以后，才会结束运行

##### 守护线程

有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，不管守护线程的代码有没有执行完，守护线程也会停止运行

```java
@Slf4j(topic = "Test12Interrupt")
public class Test14Daemon {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                boolean isInterrupted = Thread.currentThread().isInterrupted();
                if(isInterrupted) {
                    break;
                }
            }
            log.info("终止执行任务...");
        }, "thread1");
        thread.setDaemon(true);
        thread.start();

        TimeUnit.SECONDS.sleep(1);
        log.info("主线程结束运行...");
    }
}
```

##### 守护线程应用场景

1. 垃圾回收线程就是守护线程，主要程序终止，垃圾回收线程无论工作有没有做完也会停止运行
2. Tomcat中的Acceptor和Poller线程也是守护线程。所有当Tomcat接收到shutdown命令之后，不会等待它处理完当前的请求就直接停止运行

#### 3.11 五种线程状态

这是从**操作系统**层面来描述的

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\线程五种运行状态.png" alt="线程五种运行状态" style="zoom:80%;" />

1. 初始状态（创建状态）

   仅仅在语言层面创建了线程对象，还未与操作系统相关联

2. 可运行状态（就绪状态）

   指该线程已经被创建（已经与操作系统关联），可以由CPU调度执行

3. 运行状态

   指线程获取了CPU时间片，处于正在运行中的状态

   当CPU时间片运行完，线程状态会从`运行状态`切换至`可运行状态`，会导致线程上下文的切换

4. 阻塞状态

   如果调用了阻塞API，这是线程不再会占用CPU资源，会导致线程的上下文切换，进入到阻塞状态

   阻塞结束之后，操作系统会唤醒处于阻塞状态的线程，线程切换至可运行状态

   与`可运行状态`的区别是，对于`阻塞状态`的线程来说只要他们一直`不被唤醒`，调度器就不会考虑给他们分配CPU资源

5. 终止状态

   表示线程执行结束，生命周期完结，不再会切换至其他状态

#### 3.12 六种线程状态

线程的六种状态是从**Java API**层面分析的

#### 3.13 烧水泡茶案例

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\案例：烧水泡茶.png" alt="案例：烧水泡茶" style="zoom:60%;" />

#### 3.14 本章小节

1. 线程的创建方式

2. 线程的重要API

   start run sleep join interrupt 

3. 线程状态

4. <font color='red'>应用方面</font>

   1. 异步调用

      主线程执行期间，其他线程执行一下耗时的操作

   2. 提高效率

      并行计算，缩短运算时间

   3. 同步等待

      使用join方法可以实现同步等待

   4. 统筹规划

      合理进行线程之间的调度，以达到最优的效果

5. <font color='red'>原理方面</font>

   线程运行流程：栈、栈帧、上下文切换、程序计数器

   Thread类的两种创建线程方式的源码

6. <font color='red'>模式方面</font>

   两阶段终止模式

### 4. 共享模型之管程

#### 本章内容

1. 共享问题
2. synchronized
3. 线程安全分析
4. Monitor（管程的底层实现）
5. wait/notify
6. 线程状态转换
7. 活跃性（死锁、活锁、饥饿）
8. Lock（对活跃性问题进行改进）

#### 4.1 共享带来的问题

多个线程同时**读写**共享变量，可能出现线程安全问题。

> 例如：线程1写完数据之后，由于时间片用完进入**阻塞状态**，导致其操作后的数据没有及时刷新进入**主存**，线程2这个时候拿到的之前旧的数据进行读写，这个时候就出现了线程安全问题。并且线程1、线程2都没有觉得自己做错

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\线程安全问题.png" alt="线程安全问题" style="zoom:60%;" />

##### Java代码实现

> 两个线程对初始值为0的静态变量一个做自增操作，一个做自减操作，分别执行5000次，最终的结果是0吗？

```java
@Slf4j(topic = "共享模型之管程")
public class Test16 {
    
    private static int NUMBER = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    NUMBER ++;
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    NUMBER --;
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", NUMBER);
    }
}

17:02:17.416 [main] INFO 共享模型之管程 - 最终执行结果：-445
```

##### 问题分析

以上代码的执行结果可能为正数、负数、零。为什么会出现这种情况呢？因为在Java中对静态变量的自增、或者自减操作并不是原子操作，从字节码的角度分析如下：

对于 `i ++` （**i  为静态变量**）而言，实际会产生如下的**四个字节码指令**

```java
getstatic i   // 获取静态变量i的值
iconst_1      // 准备常量1
iadd          // 自增
putstatic i   // 将修改后的值存入静态变量i
```

**Java的内存模型如下：**

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\Java内存模型.png" alt="Java内存模型" style="zoom:60%;" />

##### 临界区 Critical Section

一个程序运行多个线程本身是没有问题的，问题出现在多个线程访问**共享资源**。多个线程对共享资源进行**读操作**也是没有问题的，如果多个线程对共享资源进行**写操作**可能出现**指令交错**的问题，也就是线程安全问题

 一个代码块内如果出现多个线程对共享资源进行**读写操作**，那么这个代码块称之为**临界区**

```java
static int counter = 0;

static void increment(){
 // 临界区
 counter++;
}
static void decrement(){
 // 临界区
 counter--;
}
```

##### 竞态条件 Race Condition

多个线程在临界区内执行，由于**代码的执行序列不同**（字节码的执行序列）而导致程序的结果无法预测，称之发生了竞态条件

#### 4.2 synchronized解决方案

##### ❗ 应用之互斥

为了避免在临界区内发生竞态条件，有以下两种方案可以解决该问题

1. 阻塞式解决方案：Synchronized、Lock
2. 非阻塞式解决方案：原子变量

本章节使用的是Synchronized解决方案解决竞态条件问题。Synchronized俗称**对象锁**，它采用的互斥机制让同一时刻最多有一个线程持有对象锁，其他线程再想获取对象锁就会被阻塞掉。这样就可以保证拥有锁的线程可以安全地执行临界区内的代码，而不用担心上下文切换的问题。

**注意**

虽然Java中**互斥**和**同步**都是基于Synchronized实现的，但是它们还是有区别的

1. 互斥是保证临界区的竞态条件发生时，同一时刻只能有一个线程执行临界区内的代码
2. 同步是由于线程的执行顺序不同，需要一个线程等待另一个线程运行到一个点

##### synchronized语法

```java
// 线程1， 线程2(blocked)
synchronized(对象) {
 // 临界区
}
```

```java
@Slf4j(topic = "共享模型之管程")
public class Test16fSynchronized {
    
    private static int NUMBER = 0;

    private final static Object LOCK = new Object();
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    synchronized (LOCK) {
                        NUMBER ++;
                    }
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    synchronized (LOCK) {
                        NUMBER --;
                    }
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", NUMBER);
    }
}
```

##### 思考

synchronized本质使用**对象锁**保证了**临界区代码的原子性**，临界区内的代码对外是不可分割的，不会被线程的切换所打断

为了加深理解，请思考一下问题：

1. 如果把synchronized关键字放在for循环外面，会怎样？（原子性问题）

   synchronized关键字放在for的话，**保证了20000行 JVM字节码指令的原子性**。和保证4行字节码指令原子性格哪个**性能**更高？

2. 如果t1 是synchronized( obj1) 但是t2 synchronized( obj2)会怎样？（应该持有同一个锁对象）

   在使用synchronized时，我们应该保证不同线程锁的是同一个对象，否则临界区代码仍然会因为线程切换出现不能保证原子性问题，仍然会出现线程安全问题

3. 如果t1 是synchronized( obj1) 但是t2 没有使用synchronized会怎么样？（所有线程都应该持有同一个锁对象）

   t2线程没有加锁，所以在t1线程持有锁的时候，t1不会出现阻塞状态，仍然会出现线程安全问题

##### 面向对象改进

```java
@Slf4j(topic = "共享模型之管程")
public class Test17Synchronized {
    
    public static void main(String[] args) throws InterruptedException {

        Room room = new Room();

        Thread thread1 = new Thread("increase thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    room.increment();
                }
            }
        };

        Thread thread2 = new Thread("decrease thread"){
            @Override
            public void run() {
                for (int i = 0; i < 5000; i++) {
                    room.decrement();
                }
            }
        };

        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        log.info("最终执行结果：{}", room.getCounter());
    }
}

class Room {
    private int counter = 0;

    public void increment () {
        synchronized (this) {
            counter ++;
        }
    }

    public void decrement () {
        synchronized (this) {
            counter --;
        }
    }

    /**
     * 在进行读操作的时候也需要保证互斥，防止在其他线程写的过程中读取脏数据
     * @return 获取counter的数值
     */
    public int getCounter () {
        synchronized (this) {
            return counter;
        }
    }
}
```

#### 4.3 方法上的synchronized

##### synchronized方法

```java
class Test {
	// 普通成员方法
    public synchronized void increment () {
    }

    // 等价于 所得是this对象
    public void increment1 () {
        synchronized(this) {

        }
    }
}
```

```java
class Test {
	// 静态成员方法
    public synchronized static void increment2 () {

    }
	// increment2等价于increment3，所得是Test类
    public static void increment3 () {
        synchronized(Test.class) {

        }
    }
}
```

##### 所谓的“线程八锁”

其实就是考察的synchronized锁的是哪个对象

1. 情况1

   锁的是**this对象**

   输出 1 2 或者 2 1

   ```java
   // 
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() -> {
               number.fun1();
           }).start();
           new Thread(() -> {
               number.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       public synchronized void fun1() {
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

2. 情况2 

   一秒后输出1 2，或者先输出2  然后一秒后输出1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   
   17:04:02.035 [Thread-0] INFO Test18 - thread1 begin
   17:04:02.035 [Thread-1] INFO Test18 - thread2 begin
   17:04:03.039 [Thread-0] INFO Number - 1
   17:04:03.039 [Thread-1] INFO Number - 2
   ```

3. fun3是同步方法，不存在互斥情况

   ```java
   // 3 1s后 12
   // 23 1s后 1
   // 32 1s后 1
   ```

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number.fun2();
           }).start();
           new Thread(() -> {
               log.info("thread3 begin");
               number.fun3();
           }).start();
       }
   }
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   
       public void fun3() {
           log.info("3");
       }
   }
   ```

4. 两个锁对象

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
   
           new Thread(() ->{
               number1.fun1();
           }).start();
           new Thread(() -> {
               number2.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
       /**
        * 锁的是this对象
        */
       @SneakyThrows
       public synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

5. 两个锁对象（一个this锁对象、一个Number.class对象）**没有互斥**

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
   
           new Thread(() ->{
               log.info("thread1 begin");
               number1.fun1();
           }).start();
           new Thread(() -> {
               log.info("thread2 begin");
               number1.fun2();
           }).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是this对象
        */
       public synchronized void fun2() {
           log.info("2");
       }
   }
   
   
   17:32:08.952 [Thread-1] INFO Test18 - thread2 begin
   17:32:08.952 [Thread-0] INFO Test18 - thread1 begin
   17:32:08.955 [Thread-1] INFO Number - 2
   17:32:09.955 [Thread-0] INFO Number - 1
   ```

6. 锁的是同一个Number.class对象（**有互斥**）
   2 1s后 1

   1s后 12

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number1.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 Number.class
        */
       public static synchronized void fun2() {
           log.info("2");
       }
   }
   
   17:34:10.758 [Thread-0] INFO Test18 - thread1 begin
   17:34:10.758 [Thread-1] INFO Test18 - thread2 begin
   17:34:11.761 [Thread-0] INFO Number - 1
   17:34:11.761 [Thread-1] INFO Number - 2
   ```

7. 线程1锁的是Number.class对象，线程2锁的是this对象，**不存在互斥现象**

   2 1s后 1

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number2.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 this对象
        */
       public synchronized void fun2() {
           log.info("2");
       }
   }
   ```

8. 线程1锁的是Number.class对象，线程2锁的是Number.class对象，（**有互斥**）

   2 1s后 1

   1s后 12

   ```java
   @Slf4j(topic = "Test18")
   public class Test18 {
       public static void main(String[] args) {
           Number number1 = new Number();
           Number number2 = new Number();
           new Thread(() -> number1.fun1()).start();
           new Thread(() -> number2.fun2()).start();
       }
   }
   
   @Slf4j(topic = "Number")
   class Number {
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun1() {
           TimeUnit.SECONDS.sleep(1);
           log.info("1");
       }
   
       /**
        * 锁的是 Number.class对象
        */
       @SneakyThrows
       public static synchronized void fun2() {
           log.info("2");
       }
   }
   ```

   

#### 4.4 变量的线程安全分析

##### 成员变量和静态变量是否线程安全？

1. 如果他们没有被共享，则线程安全
2. 如果他们被共享了，这是还要根据读写操作来确定线程安全的问题
   1. 如果只有读取操作，则线程安全
   2. 如果既有读操作、又有写操作，则这段代码是临界区，需要考虑线程安全问题

##### 局部变量是否线程安全？

1. 局部变量是线程安全的
2. 但是局部变量引用的对象未必是线程安全的
   1. 如果该对象没有逃离方法的作用范围，则他是线程安全的
   2. 反之则是非线程安全的

##### 局部变量线程安全分析

##### 常见的线程安全类

1. String
2. Integer
3. StringBuffer
4. Random
5. Vector
6. Hashtable
7. java.util.concurrent包下的类

这里说的线程安全指的是多个线程调用同一个实例的某一个方法时，是线程安全的

```java
Hashtable hashTable = new Hashtable();
new Thread(() -> hashTable.put("key", "value")).start();
new Thread(() -> hashTable.put("key", "value")).start();
```

**它们每个方法是原子的，但是它们的方法的组合就不是原子的**

如下方法不是线程安全的

```java
Hashtable hashTable = new Hashtable();
if(hashTable.get("key") == null) {
    hashTable.put("key", "value");
}
```

##### 不可变类线程安全性

String、Integer都是不可变类，其内部的状态都是不可变的，因此其方法都是线程安全的

#### 4.5习题

##### 买票练习

测试下面代码是否存在线程安全问题，如果有的话并进行修复

**模拟多人卖票**（sell方法加上 synchronized关键字以后是线程安全的）

```java
@Slf4j(topic = "ExerciseSell")
public class Test19ExerciseSell {

    // Random 是线程安全的
    private static Random random = new Random();

    public static void main(String[] args) throws InterruptedException {
        TicketWindow window = new TicketWindow(1000);

        List<Thread> threadList = new ArrayList<>();
        List<Integer> sellNumberList = new Vector<>();
        // 模拟多人买票
        for (int i = 0; i < 2000; i++) {
            Thread thread = new Thread(() -> {
                // 卖出去的票数
                int sellNumber = window.sell(randomAmount());
                sellNumberList.add(sellNumber);
            });
            thread.start();
            threadList.add(thread);
        }

        for (Thread thread : threadList) {
            thread.join();
        }

        // 卖出去的票总数
        int sellCount = sellNumberList.stream().mapToInt(item -> item).sum();
        log.info("卖出去的票总数:{}", sellCount);
        // 剩余票数量
        int surplusCount = window.getCount();
        log.info("剩余票数量:{}", surplusCount);

        log.info("卖出去的票总数 + 剩余票数量 :{}", sellCount + surplusCount);
    }

    /**
     * @return 生成随机数1-5
     */
    public static int randomAmount() {
        return random.nextInt(5) + 1;
    }
}

/**
 * 售票窗口
 */
class TicketWindow {

    private int count;

    public TicketWindow(int count) {
        this.count = count;
    }

    /**
     * @return 获取余票数量
     */
    public int getCount() {
        return this.count;
    }

    /**
     * 售票
     * @param amount 卖出去的票数
     * @return 卖出去的票数
     */
    public synchronized int sell(int amount) {
        if(this.count >= amount) {
            this.count -= amount;
            return amount;
        }else {
            return 0;
        }
    }
}
```

**转账场景模拟** （transfer方法加上synchronized关键字，锁住的是Account.class对象）

```java
@Slf4j(topic = "ExerciseTransfer")
public class Test20ExerciseTransfer {

    // Random 为线程安全
    private static Random random = new Random();

    public static void main(String[] args) throws InterruptedException {
        Account a = new Account(1000);
        Account b = new Account(1000);
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                a.transfer(b, randomAmount());
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                b.transfer(a, randomAmount());
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 查看转账2000次后的总金额
        log.debug("total:{}",(a.getMoney() + b.getMoney()));
    }

    // 随机 1~100
    public static int randomAmount() {
        return random.nextInt(100) +1;
    }
}

class Account {
    private int money;
    public Account(int money) {
        this.money = money;
    }
    public int getMoney() {
        return money;
    }
    public void setMoney(int money) {
        this.money = money;
    }
    public void transfer(Account target, int amount) {
        synchronized (Account.class) {
            if (this.money > amount) {
                this.setMoney(this.getMoney() - amount);
                target.setMoney(target.getMoney() + amount);
            }
        }
    }
}
```

#### 4.6 Monitor概念

##### Java对象头

*以32位虚拟机为例*

1. 普通对象

   ```java
   |--------------------------------------------------------------|
   | Object Header (64 bits)                                      |
   |------------------------------------|-------------------------|
   | Mark Word (32 bits)                | Klass Word (32 bits)    |
   |------------------------------------|-------------------------|
   ```

2. 数组对象

   ```java
   |---------------------------------------------------------------------------------|
   |                                Object Header (96 bits)                          |
   |--------------------------------|-----------------------|------------------------|
   |              Mark Word(32bits) | Klass Word(32bits)    | array length(32bits)   |
   |--------------------------------|-----------------------|------------------------|
   ```

3. 其中mark work结构如为

   ```java
   |-------------------------------------------------------|--------------------|
   |                  Mark Word (32 bits)                  |      State         |
   |-------------------------------------------------------|--------------------|
   | hashcode:25 | age:4 | biased_lock:0         | 01      |      Normal        |
   |-------------------------------------------------------|--------------------|
   | thread:23 | epoch:2 | age:4 | biased_lock:1 | 01      |      Biased        |
   |-------------------------------------------------------|--------------------|
   | ptr_to_lock_record:30                       | 00      | Lightweight Locked |
   |-------------------------------------------------------|--------------------|
   | ptr_to_heavyweight_monitor:30               | 10      | Heavyweight Locked |
   |-------------------------------------------------------|--------------------|
   |                                             | 11      |  Marked for GC      |
   |-------------------------------------------------------|--------------------|
   ```

*64 位虚拟机 Mark Word*

```java
|--------------------------------------------------------------------|--------------------|
| Mark Word (64 bits)                                                | State              |  
|--------------------------------------------------------------------|--------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01    | Normal             |
|--------------------------------------------------------------------|--------------------|
| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1     | 01    | Biased             |
|--------------------------------------------------------------------|--------------------|
| ptr_to_lock_record:62                                      | 00    | Lightweight Locked |
|--------------------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:62                              | 10    | Heavyweight Locked |
|--------------------------------------------------------------------|--------------------|
|                                                            | 11    | Marked for GC      |
|--------------------------------------------------------------------|--------------------|
```

##### Monitor（锁）

Monitor被称之为**监视器**或者**管程**，每个java对象都可以关联一个 monitor对象，如果使用synchronized给对象上锁（**重量级锁**）之后，

该对象头中的mark word就被设置为指向**monitor对象的指针**

**monitor结构如下**

<img src="D:\KUHAN Project\notes\doc\Java并发编程\imgs\monitor结构.png" alt="monitor结构" style="zoom:60%;" />

1. 刚开始monitor对象中的owner为null
2. 当thread2执行到synchronized(obj) 时，就会将monitor的owner设置为thread2（每一个monitor只能一个owner）
3. 当thread2在持有锁的过程中，如果thread3、thread4、thread5也来执行synchronized(obj)，就会进入EntryList阻塞队列中，处于BLOCKED阻塞状态
4. thread2执行完临界区中的代码完之后，开始唤醒EntryList阻塞队列中的线程来竞争锁，这个时候锁的竞争不一定是公平的（先进入阻塞队列中的线程不一定可以先竞争到锁）
5. 图中WaitSet集合中的thread0、thread1是之前获得过锁，但是条件不满足进入WAITING状态的线程，在后面的wait-notify章节中会讲到

**注意**

1. synchronized必须是进入同一个对象的monitor才会有上述效果
2. 不加synchronized的对象不会关联monitor监视器，不会有上述效果

##### 原理之synchronized

##### 原理之synchronized进阶







