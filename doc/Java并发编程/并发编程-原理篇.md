## 并发编程  原理篇

### 指令级并行原理

#### 1.名词

##### Clock Cycle Time

主频的概念大家接触的比较多，而CPU的Clock Cycle Time（时钟周期时间）,等于主频的倒数，意思是**CPU能够识别的最小时间单位**，比如说4G主频的Clock Cycle Time就是0.25 ns，作为对比，我们墙上挂的时钟的Cycle Time为1s

应用：运行一条加法指令一般需要一个时钟周期

##### CPI

有的指令需要更多的时钟周期时间运行，所以引入了Cycle Per Instruction指令平均时钟周期

##### IPC

Instruction Per Clock Cycle即CPI的倒数，表示每个时钟周期可以运行的指令数

##### CPU执行时间

程序的CPU执行时间，即我们前面提到的user + system时间，可以用下面公式来表示

```shell
程序CPU执行时间 = 指令数 * CPI *  Clock Cycle Time
```

#### 2.鱼罐头故事

加工一条鱼需要50分钟，只能一条鱼一条鱼顺序加工（**同一条鱼当前加工步骤必须等到上一个步骤执行结束才可以执行**）

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/顺序加工一条鱼.4esxn6eto8w0.png" alt="顺序加工一条鱼" style="zoom:50%;" />

为了提高工作效率，我们可以将每个加工鱼罐头流程细分为五个步骤

1. 去鳞清洗10分钟
2. 蒸煮沥水10分钟
3. 加注汤料10分钟
4. 杀菌出锅10分钟
5. 真空封罐10分钟

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/拆分步骤并行执行.1pc640du85ls.png" alt="拆分步骤并行执行" style="zoom:50%;" />

即使只有一个工人，最理想的情况是：他能够在10分钟内同时做好5件事情，因为第一条鱼的真空封罐并不会影响第二条鱼的杀菌出锅

#### 3.指令重排序优化

事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的CPU指令。一条CPU指令还可以再划分为五个子阶段，例如每个指令可以划分为：**取指令IF（Instruction Fetch）**、**指令译码ID（Instruction Decode）**、**执行指令EX（Execute）**、**内存访问MEM（Memory Access）**、**数据写回WB（Register Write Back）**

在不改变程序运行结果的前提下，这些指令的各个阶段可以通过**重排序**和**组合**来实现**指令级并行运行**，这一技术在上个世界80年代占据了计算机架构的重要地位

*提示：分阶段、分工是提升效率的关键*

```java
// 指令重排的前提是不能影响程序执行结果
// 可以进行指令重排的例子
int a = 10; // 指令1
int b = 20; // 指令2
System.out.println(a + b);

// 不可以进行指令重排的例子
int a = 10; // 指令1
int b = a - 20; // 指令2
```

#### 4.支持流水线的处理器

现代CPU支持多级指令流水线，例如支持同时执行`取指令`、`指令译码`、`指令执行`、`内存访问`、`数据写回`的处理器，就可以称之为`五级指令流水线处理器`这时CPU可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1

**指令流水线技术并不是缩短单个指令的执行时间，而是变相提高了执行运行的吞吐率**

> 提示：奔腾四支持高达35级流水线，但是由于功耗太高被逐渐废弃

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/五级指令流水线.327891dwrqk0.png" alt="五级指令流水线" style="zoom:50%;" />



#### 5.SuperScalar 处理器

### CPU缓存结构原理

### Volatile原理

volatile的底层实现原理是内存屏障，memory barrier（memory Fence）

1. 对volatile变量的写指令之后的指令会加入写屏障中，之前的对所有共享变量的改动都会同步到主存当中
2. 对volatile变量的读指令**之后**会加入读屏障

##### 如何保证可见性

写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中

```java
public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready变量用volatile关键字修饰
    // 写屏障
}
```

读屏障（lfence）保障在该读屏障之后，对共享变量的读取，加载的是主存中最新的数据

```java
public void actor1(I_Result r) {
    // 读屏障
    // ready变量用volatile关键字修饰
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
```



##### 如何保证有序性

#####  double-checked locking 问题

##### double-checked locking 解决

### Final原理

### Monitor原理

### synchronized原理

### wait&nofity原理

### join原理

### park&unpark原理

### AQS原理

### ReentrantLock原理

### 读写锁原理

### Semaphore原理

### ConcurrentHashMap原理

### LinkedBlockingQueue原理

### ConcurrentLinkedQueue原理



