#### 两阶段终止线程模式

##### 问题描述

如何在线程T1**优雅**地终止线程T2，这里优雅指的是给线程T2*料理后事*（**释放锁**）的机会

##### 错误思路

1. 使用线程的`stop方法`停止线程

   stop方法会真正地杀死线程，如果这个时候线程锁住了**共享资源**，那么当它被杀死以后就再也**没有机会释放锁**了，其他线程也就永远无法获取锁

2. 使用System.exit() 方法停止线程

   我们的需求是仅仅停止一个线程，但是这种方法会让整个进程都停止

##### 两阶段终止模式流程图

<img src="https://i.loli.net/2021/06/20/YJB7mHMwfQr6gOP.png" alt="image-20210620115536922" style="zoom:80%;" />

```java
@Slf4j(topic = "Test13Interrupt")
public class Test13Interrupt {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination twoPhaseTermination = new TwoPhaseTermination();

        twoPhaseTermination.start();

        // 3.5秒以后 打断监控线程
        TimeUnit.MILLISECONDS.sleep(3500);
        twoPhaseTermination.stop();
    }
}


@Slf4j(topic = "TwoPhaseTermination")
class TwoPhaseTermination {
    /**
     * 监控线程
     */
    private Thread monitorThread;

    /**
     * 启动监控线程
     */
    public void start() {
        monitorThread = new Thread(() -> {
            while (true) {
                Thread currentThread = Thread.currentThread();
                boolean isInterrupted = currentThread.isInterrupted();
                if(isInterrupted) {
                    log.info("监控线程被打断，料理后事，正常退出...");
                    break;
                }else {
                    try {
                        // 情况1： 在睡眠过程中被打断
                        TimeUnit.SECONDS.sleep(1);

                        // 情况2： 在正常执行监控任务过程中被打断
                        log.info("执行监控任务");

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        // 当程序处于睡眠阻塞状态时，这时候对其打断，打断标记为假，我们需要手动设置打断标记为真
                        currentThread.interrupt();
                    }
                }
            }
        });
        monitorThread.start();
    }

    /**
     * 停止监控线程
     */
    public void stop() {
        monitorThread.interrupt();
    }
}


12:22:40.516 [Thread-0] INFO TwoPhaseTermination - 执行监控任务
12:22:41.521 [Thread-0] INFO TwoPhaseTermination - 执行监控任务
12:22:42.521 [Thread-0] INFO TwoPhaseTermination - 执行监控任务
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at java.lang.Thread.sleep(Thread.java:340)
	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
	at com.kuhan.ops.monitor.system.TwoPhaseTermination.lambda$start$0(Test13Interrupt.java:47)
	at java.lang.Thread.run(Thread.java:748)
12:22:43.014 [Thread-0] INFO TwoPhaseTermination - 监控线程被打断，料理后事，正常退出...
```

#### 同步模式之保护性暂停

##### 定义

保护性暂停即Guarded Suspension，一个线程等待另一个线程的执行结果

**要点：**

1. 有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject
2. 如果有结果不断地从一个线程传递到另外一个线程，可以使用消息队列实现（生产者/消费者模型）
3. JDK中，join的实现、future的实现就是使用的这种模式
4. 因为要等待另一个线程的执行结果，因此这种模式归类为**同步模式**

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/同步模式之保护性暂停.png" alt="同步模式之保护性暂停" style="zoom:67%;" />



##### 实现

```java
@Slf4j(topic = "Test23GuardObject")
public class Test23GuardObject {
    public static void main(String[] args) {

        GuardObject guardObject = new GuardObject();

        new Thread(() -> {
            log.info("等待结果");
            List<String> result = (List<String>) guardObject.get();
            log.info("结果长度：{}", result.size());
        }).start();

        new Thread(() -> {
            try {
                log.info("结算结果");
                List<String> download = Downloader.download();
                guardObject.complete(download);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

class GuardObject {

    // 结果
    private Object response;

    /**
     * @return 获取结果
     */
    public Object get() {
        synchronized (this) {
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return this.response;
        }
    }

    /**
     * 写入结果
     * @param response 数据
     */
    public void complete(Object response) {
        synchronized (this) {
            // 结果赋值
            this.response = response;
            // 通知所有等待的线程
            this.notifyAll();
        }
    }
}
```

```java
public class Downloader {
    public static List<String> download() throws IOException {
        HttpURLConnection conn = (HttpURLConnection) new URL("https://www.baidu.com/").openConnection();
        List<String> lines = new ArrayList<>();
        try (BufferedReader reader =
                     new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
        }
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return lines;
    }
}
```

```java
09:52:37.347 [Thread-0] INFO Test23GuardObject - 等待结果
09:52:37.347 [Thread-1] INFO Test23GuardObject - 获取结果
09:52:43.127 [Thread-0] INFO Test23GuardObject - 结果长度：3
```



##### ❗**应用**

##### 扩展1

##### ❗**原理之**join

##### 扩展2
