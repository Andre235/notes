## 共享模型之内存

#### 本章内容

上一张讲解的monitor主要关注的多线程访问共享变量时，保证临界区代码的原子性

这一章节我们进一步深入学习共享变量在多线程之间的**可见性**问题、以及多条指令执行时的**顺序性**问题

#### Java内存模型

JMM即Java Memory Model，它定义了**主存**（共享数据例如成员变量）、**工作内存**（线程私有数据：局部变量）的抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等等

JMM主要体现在以下三个方面

1. 原子性

   保证指令执行的原子性，不会受到线程上下文切换的影响

2. 可见性

   保证指令不会受CPU缓存的影响

3. 有序性

   保证指令不会受CPU指令并行优化的影响

##### 子线程退出循环失败

```java
@Slf4j(topic = "Test1")
public class Test1 {

    private static boolean flag = true;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (flag) {
                log.info("子线程执行");
            }
        }).start();

        TimeUnit.SECONDS.sleep(1);
        log.info("主线程停止子线程");
        flag = false;
    }
}
```

##### 原因分析

1. 初始状态，T线程从主内存中读取run的值到工作内存

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/主内存.619i5em0dug0.png" alt="主内存" style="zoom: 50%;" />

2. 因为T线程要频繁从主存中读取run的值，JIT编译器会将run值得缓存到自己的高速缓存中，用以减少对主存的访问，提高效率

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/线程私有内存(高速缓存).53hkljs9re80.png" alt="线程私有内存(高速缓存)" style="zoom:50%;" />

3. 1s之后，main线程修改了run的值，并且同步至主存。但是这个时候T线层还是从自己的工作内存中读取值，结果永远是旧值

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/主存和私有内存数据不一致.554uidltyxc0.png" alt="主存和私有内存数据不一致" style="zoom:50%;" />

##### 解决方式

使用volatile关键字

他可以用来修饰**成员变量**和**静态成员**变量，可以避免线程从自己的工作内存中查找自己变量的值，必须到主存中获取数值。线程操作volatile变量都是直接操作主存中的值

##### 可见性和原子性

前面例子中体现的是可见性问题，他保证的是多个线程之间，一个线程volatile变量的修改对另外一个线程是可见的。但是不能抱着原子性，仅仅用在一个写线程和多个读线程的情况上

##### ❗模式之两阶段终止

##### ❗模式 Balking

#### 有序性

##### ❗原理之指令级并行运行

##### 诡异的结果

```java
int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
// 线程2 执行此方法
public void actor2(I_Result r) {
    num = 2;
    ready = true;
}
```

I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？

1. 情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1
2. 线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1
3. 线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）

但我告诉你，结果还有可能是 0 ，信不信吧！

这种情况下是：线程2 先执行 ready = true（**指令重排**），切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2

这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：

借助 java 并发压测工具 jcstress

```shell
mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jcstress -
DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -
DartifactId=ordering -Dversion=1.0
```

创建 maven 项目，提供如下测试类

```java
import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;

@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {

    int num = 0;
    boolean ready = false;

    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
```

执行

```java
mvn clean install
java -jar target/jcstress.jar 
```

会输出我们感兴趣的结果，摘录其中一次结果：

<img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/src/指令重排序结果.5hhie7gqjkw0.png" alt="指令重排序结果" style="zoom:50%;" />

可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了

##### 解决方法

volatile 修饰的变量，可以禁用指令重排

```java
import org.openjdk.jcstress.annotations.*;
import org.openjdk.jcstress.infra.results.I_Result;

@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {

    int num = 0;
    volatile boolean ready = false;

    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
```

##### happens-before

##### ❗原理之volatile

##### ❗模式之线程安全的案例模式
