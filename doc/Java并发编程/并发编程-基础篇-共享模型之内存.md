## 共享模型之内存

#### 本章内容

上一张讲解的monitor主要关注的多线程访问共享变量时，保证临界区代码的原子性

这一章节我们进一步深入学习共享变量在多线程之间的**可见性**问题、以及多条指令执行时的**顺序性**问题

#### Java内存模型

JMM即Java Memory Model，它定义了**主存**（共享数据例如成员变量）、**工作内存**（线程私有数据：局部变量）的抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等等

JMM主要体现在以下三个方面

1. 原子性

   保证指令执行的原子性，不会受到线程上下文切换的影响

2. 可见性

   保证指令不会受CPU缓存的影响

3. 有序性

   保证指令不会受CPU指令并行优化的影响

##### 子线程退出循环失败

```java
@Slf4j(topic = "Test1")
public class Test1 {

    private static boolean flag = true;
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (flag) {
                log.info("子线程执行");
            }
        }).start();

        TimeUnit.SECONDS.sleep(1);
        log.info("主线程停止子线程");
        flag = false;
    }
}
```

##### 原因分析

1. 初始状态，T线程从主内存中读取run的值到工作内存

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/主内存.619i5em0dug0.png" alt="主内存" style="zoom: 50%;" />

2. 因为T线程要频繁从主存中读取run的值，JIT编译器会将run值得缓存到自己的高速缓存中，用以减少对主存的访问，提高效率

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/线程私有内存(高速缓存).53hkljs9re80.png" alt="线程私有内存(高速缓存)" style="zoom:50%;" />

3. 1s之后，main线程修改了run的值，并且同步至主存。但是这个时候T线层还是从自己的工作内存中读取值，结果永远是旧值

   <img src="https://cdn.jsdelivr.net/gh/Andre235/-community@master/主存和私有内存数据不一致.554uidltyxc0.png" alt="主存和私有内存数据不一致" style="zoom:50%;" />

##### 解决方式

使用volatile关键字

他可以用来修饰**成员变量**和**静态成员**变量，可以避免线程从自己的工作内存中查找自己变量的值，必须到主存中获取数值。线程操作volatile变量都是直接操作主存中的值

##### 可见性和原子性

前面例子中体现的是可见性问题，他保证的是多个线程之间，一个线程volatile变量的修改对另外一个线程是可见的。但是不能抱着原子性，仅仅用在一个写线程和多个读线程的情况上

